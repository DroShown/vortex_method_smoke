// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Simulate

#define GROUP_SIZE_X 128

#include "ParticleCluster.cginc"
#include "VortexMethod.cginc"
#include "SharedReduce.cginc"
#include "Grid.cginc"
#include "Command.cginc"

_GRID_DEF_UNIFORM(Heat);
Texture3D<float> uHeatTexture;
SamplerState sampler_uHeatTexture;

_VM_DEF_UNIFORM(VM);
_VM_DEF_FUNC(VM);

PC_DEF_UNIFORM
PC_DEF_BUFFER(TracerParticle)
PC_DEF_BUFFER_RW(TracerParticle)

_PC_DEF_UNIFORM(Vortex)
_PC_DEF_BUFFER(Vortex, VortexParticle)

float uDeltaTime;

float buoyancy_velocity_from_pos(in const float3 pos) {
    float3 uvw = _GRID_WORLD2UVW(Heat, pos);
    return uHeatTexture.SampleLevel(sampler_uHeatTexture, uvw, 0) * _VM_HEAT_BUOYANCY_FACTOR(VM);
}

SR_DEF_SHARED_BUFFER(PosVor, PosVor, GROUP_SIZE_X);

[numthreads(GROUP_SIZE_X, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID, uint group_idx : SV_GroupIndex) {
    uint src_idx = id.x;
    TracerParticle p = PC_GET(SAFE, src_idx);
    p.life -= uDeltaTime;

    float3 v = float3(0, 0, 0);
    #define LOAD_POS_VOR(X) pos_vor_from_vortex_particle(uVortexParticles[X])
    #define REDUCE_POS_VOR(P) v += velocity_from_pos_vor(p.pos, P)
    uint s = _PC_IDX(Vortex, 0), t = s + _PC_COUNT(Vortex);
    SR_REDUCE(PosVor, PosVor, GROUP_SIZE_X, group_idx, s, t, LOAD_POS_VOR, REDUCE_POS_VOR);
    
    v.y += buoyancy_velocity_from_pos(p.pos);
    p.pos += v * uDeltaTime;

    /* if (p.pos.y <= 10)
        v.y += buoyancy_velocity_from_pos(p.pos);
    p.pos += v * uDeltaTime;
    if (p.pos.y > 10)
        p.pos.y = 10 - abs(v.y) * uDeltaTime; */

    if (src_idx < PC_COUNT && p.life >= 0)
        PC_PUSH(SAFE, p);
}